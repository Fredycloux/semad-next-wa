generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"   // Usamos Postgres en Vercel
  url      = env("DATABASE_URL")
}

enum Dentition {
  ADULT
  CHILD
}

enum Role {
  ADMIN
  ODONTOLOGO
  RECEPCION
}

enum Surface {
  O   // oclusal/incisal
  M   // mesial
  D   // distal
  B   // vestibular/bucal
  L   // lingual/palatina
}

enum Sex {
  MALE
  FEMALE
  OTHER
}

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  name         String?
  email        String?  @unique
  passwordHash String
  role         Role     @default(RECEPCION)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model Patient {
  id           String   @id @default(cuid())
  fullName     String
  document     String?
  phone        String?
  email        String?
  insurer      String?
  allergies    String?
  history      String?
  // NUEVOS
  dateOfBirth  DateTime?
  sex          Sex?
  pregnant     Boolean?

  dentition   Dentition          @default(ADULT)
  appointments Appointment[]
  invoices     Invoice[]
  odontogram   OdontogramEntry[]  // <- relación con el odontograma
  consultations Consultation[]   // NUEVO

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model Appointment {
  id        String   @id @default(cuid())
  date      DateTime
  reason    String?
  dentist   String?
  status    String   @default("Programada")
  patient   Patient  @relation(fields: [patientId], references: [id])
  patientId String

  consultations Consultation[]
}

model InventoryItem {
  id      String @id @default(cuid())
  name    String
  code    String @unique
  unit    String?
  stock   Int    @default(0)
  minimum Int    @default(0)
  cost    Int    @default(0)
  price   Int    @default(0)
}

model Procedure {
  id        Int      @id @default(autoincrement())
  code      String   @unique
  name      String

  // PRECIO
  price     Int?         // precio fijo sugerido (null si usas rango)
  variable  Boolean @default(false)
  minPrice  Int?         // “desde”
  maxPrice  Int?         // “hasta” (opcional)
  unit      String?      // p.ej. "c/u", "pieza", etc.

  invoices  InvoiceItem[]
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  consultations ConsultationProcedure[]
}

// Sencillo “contador” para folios.
model Counter {
  name  String @id
  value Int    @default(0)
}

model Invoice {
  id        String       @id @default(cuid())
  folio     String?      @unique            // <-- NUEVO
  date      DateTime     @default(now())
  patient   Patient      @relation(fields: [patientId], references: [id])
  patientId String
  items     InvoiceItem[]
  total     Int          @default(0)       // total en COP
}

model InvoiceItem {
  id            String    @id @default(cuid())
  quantity      Int       @default(1)
  tooth         String?

  // guarda el precio que realmente cobraste (necesario si hay rango)
  total         Int       @default(0)   // opcional, o calcúlalo en el server
  notes         String?   // p.ej. "multirradicular", "cordal", etc.

  procedure     Procedure @relation(fields: [procedureCode], references: [code])
  procedureCode String
  unitPrice     Int        @default(0) // <-- precio unitario facturado (en COP)
  subtotal      Int        @default(0) // <-- quantity * unitPrice
  invoice       Invoice    @relation(fields: [invoiceId], references: [id])
  invoiceId     String
}

model OdontogramEntry {
  id        String       @id @default(cuid())
  patientId String
  patient   Patient      @relation(fields: [patientId], references: [id])
  tooth     String
  surface   Surface
  label     String
  color     String?
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  @@unique([patientId, tooth, surface], name: "patientId_tooth_surface")
  @@index([patientId])
}

model Dentist {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Consultation {
  id            String   @id @default(cuid())
  date          DateTime @default(now())

  patient       Patient  @relation(fields: [patientId], references: [id])
  patientId     String
  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  appointmentId String?

  // examen físico
  temperature   Float?
  pulse         Int?
  respRate      Int?
  systolicBP    Int?
  diastolicBP   Int?

  // textos
  anamnesis     String?
  diagnosis     String?
  evolution     String?
  prescription  String?

  procedures    ConsultationProcedure[]   // join con Procedure

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model ConsultationProcedure {
  consultation   Consultation @relation(fields: [consultationId], references: [id])
  consultationId String
  procedure      Procedure    @relation(fields: [procedureId], references: [id])
  procedureId    Int

  @@id([consultationId, procedureId])
}
